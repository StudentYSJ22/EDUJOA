CREATE TABLE EMPLOYEE(
EMP_ID VARCHAR2(100) PRIMARY KEY,
EMP_NAME VARCHAR2(100) NOT NULL,
EMP_PASSWORD VARCHAR2(100) NOT NULL,
EMP_EMAIL VARCHAR2(100) NOT NULL UNIQUE,
EMP_TITLE VARCHAR2(100) NOT NULL,
EMP_PROFILE VARCHAR2(1000),
EMP_HIREDATE DATE DEFAULT SYSDATE,
EMP_YN VARCHAR2(100) DEFAULT '0',
EMP_ADDRESS VARCHAR2(200) NOT NULL,
EMP_RVACATION NUMBER,
EMP_TVACATION NUMBER,
EMP_SALARY NUMBER NOT NULL,
EMP_ANNUALSAL NUMBER NOT NULL,
EMP_STATUS NUMBER DEFAULT 0,
EMP_BANK VARCHAR2(100) NOT NULL,
EMP_ACCOUNT VARCHAR2(100) NOT NULL
);

CREATE SEQUENCE emp_id_seq
    START WITH 1
    INCREMENT BY 1
    NOCACHE
    NOCYCLE;
    
    CREATE OR REPLACE TRIGGER trg_emp_id
BEFORE INSERT ON EMPLOYEE
FOR EACH ROW
DECLARE
    v_seq NUMBER;
    v_date_str VARCHAR2(8);
    v_emp_id VARCHAR2(100);
BEGIN
    -- 고용일을 YYYYMMDD 형식으로 변환
    v_date_str := TO_CHAR(:NEW.EMP_HIREDATE, 'YYYYMMDD');
    
    -- 시퀀스 값 가져오기
    SELECT emp_id_seq.NEXTVAL INTO v_seq FROM dual;
    
    -- 시퀀스 값을 세 자리 숫자로 변환
    v_emp_id := 'EDU' || v_date_str || LPAD(v_seq, 3, '0');
    
    -- EMP_ID 설정
    :NEW.EMP_ID := v_emp_id;
END;
/



CREATE TABLE SUBJECT(
SUB_ID VARCHAR2(100) PRIMARY KEY,
SUB_NAME VARCHAR2(100) UNIQUE,
SUB_DETAIL VARCHAR2(100) NOT NULL
);

CREATE SEQUENCE SUB_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER SUB_TRG
BEFORE INSERT ON SUBJECT
FOR EACH ROW
WHEN (NEW.SUB_ID IS NULL)
BEGIN
  SELECT 'SUB_' || LPAD(SUB_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.SUB_ID
  FROM DUAL;
END;
/
COMMIT;


CREATE TABLE TUTOR(
TT_ID VARCHAR2(100) PRIMARY KEY,
SUB_ID REFERENCES SUBJECT(SUB_ID),
TT_NAME VARCHAR2(100) NOT NULL,
TT_PHONE VARCHAR2(100) NOT NULL UNIQUE,
TT_EMAIL VARCHAR2(100) NOT NULL UNIQUE,
TT_HIREDATE DATE DEFAULT SYSDATE,
TT_PROFILE VARCHAR2(1500),
TT_YN VARCHAR2(100) DEFAULT '0',
TT_SALARY NUMBER,
TT_ANNUALSAL NUMBER
);
CREATE SEQUENCE TUTOR_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER TUTOR_TRG
BEFORE INSERT ON TUTOR
FOR EACH ROW
WHEN (NEW.TT_ID IS NULL)
BEGIN
  SELECT 'TUTOR_' || LPAD(TUTOR_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.TT_ID
  FROM DUAL;
END;
/
COMMIT;

COMMIT;

CREATE TABLE CLASS(
CLASS_ID VARCHAR2(100) PRIMARY KEY,
TT_ID REFERENCES TUTOR(TT_ID),
CLASS_OPEN DATE,
CLASS_CLOSE DATE
);
CREATE SEQUENCE CLASS_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER CLASS_TRG
BEFORE INSERT ON CLASS
FOR EACH ROW
WHEN (NEW.CLASS_ID IS NULL)
BEGIN
  SELECT 'CLASS_' || LPAD(CLASS_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.CLASS_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE STUDENT(
STD_ID VARCHAR2(100) PRIMARY KEY,
STD_NAME VARCHAR2(100) NOT NULL,
STD_SCHOOL VARCHAR2(100) NOT NULL,
STD_PHONE VARCHAR2(100) NOT NULL,
STD_PARENT_PHONE VARCHAR2(100) NOT NULL,
STD_PAYMENT VARCHAR2(100) NOT NULL,
STD_YN NUMBER DEFAULT '0'
);
CREATE SEQUENCE STD_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER STD_TRG
BEFORE INSERT ON STUDENT
FOR EACH ROW
WHEN (NEW.STD_ID IS NULL)
BEGIN
  SELECT 'STD_' || LPAD(STD_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.STD_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE MYCLASS(
MCL_ID VARCHAR2(100) PRIMARY KEY,
STD_ID REFERENCES STUDENT(STD_ID),
CLASS_ID REFERENCES CLASS(CLASS_ID)
);
ALTER TABLE MYCLASS ADD CONSTRAINT unique_student_class UNIQUE (STD_ID, CLASS_ID);

CREATE SEQUENCE MCL_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER MCL_TRG
BEFORE INSERT ON MYCLASS
FOR EACH ROW
WHEN (NEW.MCL_ID IS NULL)
BEGIN
  SELECT 'MCL_' || LPAD(MCL_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.MCL_ID
  FROM DUAL;
END;
/

COMMIT;

CREATE TABLE SCHEDULE (
SCH_ID VARCHAR2(100) PRIMARY KEY,
TT_ID REFERENCES TUTOR(TT_ID),
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
SCH_TITLE VARCHAR2(100) NOT NULL,
SCH_CONTENT VARCHAR2(1000) NOT NULL,
SCH_START DATE DEFAULT SYSDATE,
SCH_END DATE DEFAULT SYSDATE,
SCH_TYPE VARCHAR2(100) NOT NULL,
SCH_COLOR VARCHAR2(200)
);
CREATE SEQUENCE SCH_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER SCH_TRG
BEFORE INSERT ON SCHEDULE
FOR EACH ROW
WHEN (NEW.SCH_ID IS NULL)
BEGIN
  SELECT 'SCH_' || LPAD(SCH_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.SCH_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE ATTENDANCE(
ATN_ID VARCHAR2(100) PRIMARY KEY,
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
ATN_IN TIMESTAMP,
ATN_OUT TIMESTAMP,
STN_DATE DATE DEFAULT SYSDATE,
STN_STATUS VARCHAR2(100)
);
CREATE SEQUENCE ATTD_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER ATTD_TRG
BEFORE INSERT ON ATTENDANCE
FOR EACH ROW
WHEN (NEW.ATN_ID IS NULL)
BEGIN
  SELECT 'ATN_' || LPAD(ATTD_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.ATN_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE NOTICE_BOARD(
BOARD_ID VARCHAR2(100) PRIMARY KEY,
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
BOARD_TITLE VARCHAR2(100) NOT NULL,
BOARD_CONTENT VARCHAR2(1500) NOT NULL,
BOARD_DATE DATE DEFAULT SYSDATE,
BOARD_COUNT NUMBER DEFAULT '0'
);
CREATE SEQUENCE NBOARD_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER NBOARD_TRG
BEFORE INSERT ON NOTICE_BOARD
FOR EACH ROW
WHEN (NEW.BOARD_ID IS NULL)
BEGIN
  SELECT 'BOARD_' || LPAD(NBOARD_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.BOARD_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE NOTICE_BOARD_ATTC(
NBA_ID VARCHAR2(100) PRIMARY KEY,
BOARD_ID REFERENCES NOTICE_BOARD(BOARD_ID),
NBA_SIZE VARCHAR2(1000),
NBA_PATH VARCHAR2(1000),
NBA_ORINAME VARCHAR2(1000),
NBA_RENAME VARCHAR2(300)
);
CREATE SEQUENCE NBOARD_ATTC_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER NBOARD_ATTC_TRG
BEFORE INSERT ON NOTICE_BOARD_ATTC
FOR EACH ROW
WHEN (NEW.NBA_ID IS NULL)
BEGIN
  SELECT 'NBA_' || LPAD(NBOARD_ATTC_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.NBA_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE ALARM(
ALARM_ID VARCHAR2(100) PRIMARY KEY,
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
ALARM_READ NUMBER DEFAULT '0',
ALARM_DATE DATE DEFAULT SYSDATE,
ALARM_TYPE VARCHAR2(100) NOT NULL,
ALARM_CONTENT VARCHAR2(1000) NOT NULL
);
CREATE SEQUENCE ALR_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER ALR_TRG
BEFORE INSERT ON ALARM
FOR EACH ROW
WHEN (NEW.ALARM_ID IS NULL)
BEGIN
  SELECT 'ALARM_' || LPAD(ALR_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.ALARM_ID
  FROM DUAL;
END;
/
COMMIT;


CREATE TABLE SUPERVISION(
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
TT_ID REFERENCES TUTOR(TT_ID)
);
ALTER TABLE SUPERVISION ADD CONSTRAINT unique_emp_tutor UNIQUE (EMP_ID, TT_ID);

CREATE TABLE CHAT_ROOM(
ROOM_ID VARCHAR2(100) PRIMARY KEY,
ROOM_NAME VARCHAR2(100) NOT NULL,
ROOM_DATE DATE DEFAULT SYSDATE
);
SELECT * FROM CHAT_ROOM;
CREATE SEQUENCE CHATROOM_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;
DROP TRIGGER CHATROOM_TRG;
DROP SEQUENCE CHATROOM_SEQ;
CREATE OR REPLACE TRIGGER CHATROOM_TRG
BEFORE INSERT ON CHAT_ROOM
FOR EACH ROW
WHEN (NEW.ROOM_ID IS NULL)
BEGIN
  SELECT 'ROOM_' || LPAD(CHATROOM_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.ROOM_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE CHAT_ATTENDEE(
ROOM_ID REFERENCES CHAT_ROOM(ROOM_ID),
EMP_ID REFERENCES EMPLOYEE(EMP_ID)
);
ALTER TABLE CHAT_ATTENDEE ADD CONSTRAINT unique_emp_chat UNIQUE (EMP_ID, ROOM_ID);

COMMIT;

CREATE TABLE CHAT_RECORD(
CHAT_ID VARCHAR2(100) PRIMARY KEY,
ROOM_ID REFERENCES CHAT_ROOM(ROOM_ID),
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
CHAT_TIME TIMESTAMP,
CHAT_CONTENT VARCHAR2(2000)
);
CREATE SEQUENCE CHAT_RCD_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER CHAT_TRG
BEFORE INSERT ON CHAT_RECORD
FOR EACH ROW
WHEN (NEW.CHAT_ID IS NULL)
BEGIN
  SELECT 'CHAT_' || LPAD(CHAT_RCD_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.CHAT_ID
  FROM DUAL;
END;
/
COMMIT;
CREATE TABLE CHAT_ATTACHMENT(
FILE_ID VARCHAR2(1000) PRIMARY KEY,
ROOM_ID REFERENCES CHAT_ROOM(ROOM_ID),
FILE_PATH VARCHAR2(1000) NOT NULL,
FILE_ORINAME VARCHAR2(1000) NOT NULL,
FILE_RENAME VARCHAR2(1000) NOT NULL,
FILE_SIZE VARCHAR2(1000) NOT NULL
);
CREATE SEQUENCE CHAT_FILE_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER CHAT_FILE_TRG
BEFORE INSERT ON CHAT_ATTACHMENT
FOR EACH ROW
WHEN (NEW.FILE_ID IS NULL)
BEGIN
  SELECT 'FILE_' || LPAD(CHAT_FILE_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.FILE_ID
  FROM DUAL;
END;
/

COMMIT;

CREATE TABLE APPROVAL(
APV_ID VARCHAR2(100) PRIMARY KEY,
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
APV_TYPE VARCHAR2(100) NOT NULL,
APV_TITLE VARCHAR2(200) NOT NULL,
APV_CONTENT VARCHAR2(2000) NOT NULL,
APV_DATE DATE DEFAULT SYSDATE,
APV_MODIFY DATE,
APV_DONE DATE,
APV_STATUS VARCHAR2(100) DEFAULT '0',
APV_STRG VARCHAR2(100) DEFAULT '0'
);

//CREATE TABLE APPROVAL_LINE(
//APV_LINE_ID VARCHAR2(100) PRIMARY KEY,
//EMP_ID REFERENCES EMPLOYEE(EMP_ID),
//);

CREATE SEQUENCE approval_seq
    START WITH 1
    INCREMENT BY 1
    NOCACHE;
    
    CREATE OR REPLACE TRIGGER trg_approval_id
BEFORE INSERT ON APPROVAL
FOR EACH ROW
BEGIN
    SELECT 'APV_' || TO_CHAR(SYSDATE, 'YYYYMMDD') || LPAD(approval_seq.NEXTVAL, 3, '0')
    INTO :NEW.APV_ID
    FROM DUAL;
END;
/

CREATE TABLE VACAY(
APV_ID REFERENCES APPROVAL(APV_ID),
VACAY_TYPE VARCHAR2(100) NOT NULL,
VACAY_START DATE NOT NULL,
VACAY_END DATE NOT NULL
);
COMMIT;

CREATE TABLE PRE_PAYMENT(
APV_ID REFERENCES APPROVAL(APV_ID),
PAY_CASE VARCHAR2(100) NOT NULL,
PAY_AMOUNT VARCHAR2(1000) NOT NULL,
PAY_DATE DATE NOT NULL
);

CREATE TABLE AFTER_PAYMENT(
APV_ID REFERENCES APPROVAL(APV_ID),
PAY_CASE VARCHAR2(100) NOT NULL,
PAY_AMOUNT VARCHAR2(1000) NOT NULL,
PAY_DATE DATE NOT NULL
);
COMMIT;

CREATE OR REPLACE TRIGGER trg_vacay_id
BEFORE INSERT ON VACAY
FOR EACH ROW
DECLARE
    v_apv_id APPROVAL.APV_ID%TYPE;
BEGIN
    -- APPROVAL 테이블에 새로운 레코드 삽입
    INSERT INTO APPROVAL (APV_ID)
    VALUES (approval_seq.NEXTVAL)
    RETURNING APV_ID INTO v_apv_id;

    -- 삽입된 APV_ID를 VACAY 테이블의 APV_ID로 설정
    :NEW.APV_ID := v_apv_id;
END;
/
CREATE OR REPLACE TRIGGER trg_pre_payment_id
BEFORE INSERT ON PRE_PAYMENT
FOR EACH ROW
DECLARE
    v_apv_id APPROVAL.APV_ID%TYPE;
BEGIN
    -- APPROVAL 테이블에 새로운 레코드 삽입
    INSERT INTO APPROVAL (APV_ID)
    VALUES (approval_seq.NEXTVAL)
    RETURNING APV_ID INTO v_apv_id;

    -- 삽입된 APV_ID를 PRE_PAYMENT 테이블의 APV_ID로 설정
    :NEW.APV_ID := v_apv_id;
END;
/
CREATE OR REPLACE TRIGGER trg_after_payment_id
BEFORE INSERT ON AFTER_PAYMENT
FOR EACH ROW
DECLARE
    v_apv_id APPROVAL.APV_ID%TYPE;
BEGIN
    -- APPROVAL 테이블에 새로운 레코드 삽입
    INSERT INTO APPROVAL (APV_ID)
    VALUES (approval_seq.NEXTVAL)
    RETURNING APV_ID INTO v_apv_id;

    -- 삽입된 APV_ID를 AFTER_PAYMENT 테이블의 APV_ID로 설정
    :NEW.APV_ID := v_apv_id;
END;
/
COMMIT;

CREATE TABLE APPROVAL_LINE(
APV_LINE_ID VARCHAR2(100) PRIMARY KEY,
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
APV_ID REFERENCES APPROVAL(APV_ID),
APV_SEQUENCE VARCHAR2(100)
);
CREATE SEQUENCE APV_LINE_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER APV_LINE_TRG
BEFORE INSERT ON APPROVAL_LINE
FOR EACH ROW
WHEN (NEW.APV_LINE_ID IS NULL)
BEGIN
  SELECT 'APV_LINE_' || LPAD(APV_LINE_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.APV_LINE_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE FREQUENT_LINE(
FEQ_ID VARCHAR2(100) PRIMARY KEY,
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
FEQ_NAME VARCHAR2(100)
);
CREATE SEQUENCE FEQ_SEQ
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE OR REPLACE TRIGGER FEQ_TRG
BEFORE INSERT ON FREQUENT_LINE
FOR EACH ROW
WHEN (NEW.FEQ_ID IS NULL)
BEGIN
  SELECT 'FEQ_' || LPAD(FEQ_SEQ.NEXTVAL, 3, '0')
  INTO :NEW.FEQ_ID
  FROM DUAL;
END;
/
COMMIT;

CREATE TABLE FREQUENT_PERSON(
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
FEQ_ID REFERENCES FREQUENT_LINE(FEQ_ID)
);
ALTER TABLE FREQUENT_PERSON ADD CONSTRAINT unique_emp_feqline UNIQUE (EMP_ID, FEQ_ID);
COMMIT;

CREATE TABLE CARBON_COPY(
EMP_ID REFERENCES EMPLOYEE(EMP_ID),
APV_ID REFERENCES APPROVAL(APV_ID)
);
ALTER TABLE CARBON_COPY ADD CONSTRAINT unique_emp_apv UNIQUE (EMP_ID, APV_ID);
COMMIT;

CREATE TABLE APV_ATTACHMENT( //PK가 결재의 결재번호를 참조하기 때문에 추가 트리거 작성해야함 7/27까지 구현예정
APV_ID REFERENCES APPROVAL(APV_ID),
FILE_ORINAME VARCHAR2(1000) NOT NULL,
FILE_RENAME VARCHAR2(1000) NOT NULL
);
COMMIT;


CREATE TABLE APV_TAG( //APV_TYPE은 참조 없으니 JOIN해서 사용해야함
APV_TYPE VARCHAR2(100),
PRE_PAYMENT CLOB,
AFTER_PAYMENT CLOB,
VACAY CLOB
);
COMMIT;

CREATE OR REPLACE TRIGGER TRG_SET_VACATION
BEFORE INSERT OR UPDATE ON EMPLOYEE
FOR EACH ROW
DECLARE
    v_vacation_days NUMBER;
    v_current_year NUMBER;
    v_hire_year NUMBER;
    v_years_employed NUMBER;
BEGIN
    v_current_year := EXTRACT(YEAR FROM SYSDATE);
    v_hire_year := EXTRACT(YEAR FROM :NEW.EMP_HIREDATE);
    v_years_employed := v_current_year - v_hire_year;

    IF v_hire_year = v_current_year THEN
        v_vacation_days := FLOOR(MONTHS_BETWEEN(SYSDATE, :NEW.EMP_HIREDATE));
    ELSE
        v_vacation_days := 15 + FLOOR(v_years_employed / 2);
    END IF;

    :NEW.EMP_TVACATION := v_vacation_days;
END;